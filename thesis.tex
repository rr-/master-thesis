\documentclass[12pt,a4paper,twoside]{article}
\usepackage{geometry}
\geometry{a4paper}

\usepackage[utf8]{inputenc}
\usepackage[OT1]{fontenc}
\usepackage{polski}
\usepackage{graphicx}
\usepackage{setspace}
\usepackage{fancyhdr}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{enumitem}
\usepackage{microtype}

\begin{document}
\newgeometry{margin=3cm}
\onehalfspacing

\begin{titlepage}
	\begin{center}
	{\LARGE Uniwersytet im. Adama Mickiewicza w Poznaniu \\
	Wydział Matematyki i Informatyki }
	\line(1,0){350}

	\vspace{1cm}
	\includegraphics[width=2cm]{logo-uam/logo-uam.png}
	\vspace{1cm}

	\vspace{1cm}
	{\Huge Ataki na kryptograficzne \\ funkcje skrótu} \\[0.5cm]
	{\Large Marcin Kurczewski}
	\end{center}

	\vspace{3cm}
	\hspace{8cm}\parbox[l]{6cm}{\Large Praca magisterska \\
	napisana pod kierunkiem \\
	dr Michała Rena}

	\begin{center}
	\vspace{4cm}
	Poznań, maj 2013
	\end{center}

\end{titlepage}


\newpage
\thispagestyle{empty}
\begin{center}
	OŚWIADCZENIE
\end{center}

Ja, niżej podpisany Marcin Kurczewski, student Wydziału Matematyki i
Informatyki Uniwersytetu im. Adama Mickiewicza oświadczam, że przedkładaną
pracę dyplomową pt.: "Ataki na kryptograficzne funkcje skrótu" napisałem
samodzielnie. Oznacza to, że przy pisaniu pracy, poza niezbędnymi
konsultacjami, nie korzystałem z pomocy innych osób, a w szczególności nie
zlecałem opracowania rozprawy lub jej części innym osobom, ani nie odpisywałem
tej rozprawy lub jej części od innych osób.

Oświadczam również, że egzemplarz pracy dyplomowej w formie wydruku
komputerowego jest zgodny z egzemplarzem pracy dyplomowej w formie
elektronicznej.

Jednocześnie przyjmuję do wiadomości, że gdyby powyższe oświadczenie okazało
się nieprawdziwe, decyzja o wydaniu mi dyplomu zostanie cofnięta.


\newpage
\setcounter{tocdepth}{3}
\tableofcontents

\newpage
\pagestyle{fancy}
\fancyhead[L]{\fontsize{10}{0}\selectfont
	Ataki na kryptograficzne funkcje skrótu}
\fancyhead[R]{\fontsize{10}{0}\selectfont
	Marcin Kurczewski}


\section{Wstęp}
Celem tej pracy jest przedstawienie współczesnych metod łamania
kryptograficznych funkcji skrótu, zarówno od strony praktycznej, jak i
teoretycznej. Jako główny temat technologiczny zostały wybrane funkcje
\texttt{MD5} oraz \texttt{SHA-1}.

Praca złożona jest z trzech części. Pierwsza stanowi wprowadzenie do tematyki
kryptograficznych funkcji skrótu, opisując krótko ich rys historyczny,
zgłębiając szczegółowo budowę i przedstawiając ich zastosowania.

Druga część opisuje szereg uniwersalnych technik, które można zastosować do
atakowania większości współczesnych kryptograficznych funkcji skrótu w sposób
niezależny od ich struktury. W części tej są także przedstawione podstawowe
metody obrony przed tego typu atakami.

Część trzecia prezentuje od strony technicznej wybrane wysoce wyspecjalizowane
ataki teoretyczne, jakie powstały na przestrzeni ostatnich lat, pokazując luki
w kryptograficznych funkcjach skrótu.

\newpage



\section{Wprowadzenie do tematyki}

\subsection{Terminologia użyta w pracy}

Zgodnie z terminologią używaną przez kryptologów, wprowadzone zostają
następujące terminy, które będą konsekwentnie stosowane w całej pracy:

\begin{itemize}
\item \textbf{funkcja haszująca} -- alternatywne określenie na \textbf{funkcję
skrótu},
\item \textbf{bezpieczna funkcja haszująca} -- alternatywne określenie na
\textbf{kryptograficzną funkcję skrótu},
\item \textbf{zwykła funkcja haszująca} -- funkcja skrótu, która może, ale nie
musi być kryptograficzną funkcją skrótu,
\item \textbf{wiadomość} -- wartość wejściowa dla \textbf{funkcji skrótu},
\item \textbf{skrót} -- wartość wyjściowa z \textbf{funkcji skrótu},
\item \textbf{hasz} -- alternatywne określenie na \textbf{skrót}.
\item \textbf{kolizja} -- sytuacja, w której skróty dwóch wiadomości są takie
same, tj.
\[
    \begin{aligned}
    m &\neq m' \\
    H(m) &= H(m')
    \end{aligned}
\]
\end{itemize}

Dodatkowo, od części \ref{sec:hash_construction} do końca pracy przez pojęcie
funkcji haszujących będziemy się odnosić wyłącznie do bezpiecznych funkcji
haszujących, gdyż tylko na takich funkcjach w tych częściach będziemy się
skupiać.



\subsection{Definicja zwykłej oraz kryptograficznej funkcji skrótu}

Funkcja skrótu jest to funkcja, której dziedziną są ciągi bitów dowolnej
długości, a przeciwdziedziną -- ciągi bitów o ograniczonej długości. Rzutowanie
to odbywa się w sposób jednoznaczny, tj. każdemu wejściu funkcja skrótu
przyporządkowuje dokładnie jedno wyjście; formalnie zatem jest to surjekcja:

$$ f \colon X \to Y $$
$$ |Y| \leq n, n \in \mathbb{N} $$
$$ \forall_{y \in Y} \; \exists_{x \in X} \; f(x)=y$$

Kryptograficzna funkcja skrótu to taka funkcja skrótu, która może być
wykorzystywana w zastosowaniach kryptograficznych, a więc wymagających
wysokiego poziomu bezpieczeństwa. Przykłady takich zastosowań można znaleźć w
sekcji \ref{sec:secure_hash_usages}. Dokładne cechy, jakie powinna spełniać
funkcja skrótu, aby była kryptograficzna, omówione zostały w sekcji
~\ref{sec:secure_hash_attributes}. Ponadto wszystkie funkcje skrótu,
niezależnie od swojego zastosowania w celach kryptograficznych, powinny
spełniać własności opisane w sekcji \ref{sec:common_hash_attributes}.



\subsubsection{Cechy zwykłych funkcji haszujących}
\label{sec:common_hash_attributes}



\subsubsection{Cechy kryptograficznych funkcji haszujących}
\label{sec:secure_hash_attributes}



\subsection{Zastosowania kryptograficznych funkcji skrótu}
\label{sec:secure_hash_usages}
Same funkcje skrótu mają bardzo szerokie zastosowania, my jednak skupimy się
wyłącznie na zastosowaniach \emph{kryptograficznych} funkcji haszujących. W
każdym przypadku opisane zastosowanie utylizuje podstawową cechę
kryptograficznych funkcji skrótu, jaką jest odporność na kolizje.

\subsubsection{Weryfikacja integralności danych}
\label{sec:usage_integrity_check}

Wyobraźmy sobie sytuację, w której użytkownik o imieniu Alicja zmuszony jest
przetransportować jakieś dane przez niebezpieczny kanał informacji, który jest
podatny na zakłócenia, do użytkownika imieniem Bob. Niech wiadomość wysłana
przez Alicję będzie $M$, a wiadomość odebrana przez Boba będzie $M'$.

%todo: rycina

Z taką transmisją wiąże się wiele problemów, gdy zaczniemy rozpatrywać ją pod
kątem zapewnienia bezpieczeństwa. Jednym z takim problemów jest zapewnienie
bezpiecznego mechanizmu weryfikacji, czy dane odebrane przez Boba są faktycznie
tymi samymi danymi, które były wysłane do niego przez Alicję, a więc czy nie
zostały zmienione w jakikolwiek sposób podczas transportu. Innymi słowy, należy
w jakiś sposób zweryfikować, czy $M' = M$.

Z pomocą w rozwiązaniu tego problemu przychodzą funkcje haszujące. Alicja może,
obok samej wiadomości $M$, przesłać wyliczony u siebie skrót tej wiadomości,
$H(M)$. Bob może wówczas zweryfikować integralność odebranych danych $M'$
poprzez obliczenie ich skrótu po swojej stronie $H(M')$, a w następnej
kolejności porównanie samych skrótów (sprawdzenie, czy obliczony przez Alicję
$H(M)$ jest równy obliczonemu przez niego $H(M')$).

Wprowadzenie funkcji haszujących właśnie pozwoliło sprowadzić problem
zabezpieczenia transmisji potencjalnie bardzo długich komunikatów do
zabezpieczenia transmisji jedynie samych skrótów.

Należy zdawać sobie sprawę, że nie rozwiązuje to problemu zabezpieczenia
transmisji przed rozmyślnymi atakami -- jeśli ktoś mógł wcześniej edytować $M$,
teraz może również edytować wartość $H(M)$. Ponadto funkcje haszujące nie
zapewniają żadnej poufności danych. Mimo to z ich zastosowania płyną pewne
wymienione niżej korzyści.

\begin{itemize}
\item Rozwiązanie to jest przydatne w sytuacjach, kiedy nie mamy do czynienia z
rozmyślnymi atakami, a jedynie przypadkowymi zakłóceniami --
prawdopodobieństwo, że skrót $H(M')$ będzie równy $H(M)$ w sytuacji, kiedy $M
\neq M'$ będzie minimalne. Jest to jedno z naturalnych zastosowań funkcji
haszujących, w których odgrywają rolę trudnej do podrobienia sumy kontrolnej.
\item Ponadto ułatwione jest napisanie innych protokołów -- dzięki funkcjom
haszującym zależy nam na zabezpieczeniu przed modyfikacją nie całej wiadomości,
a jedynie jej malutkiego kawałka zawierającego jej skrót. Przykładem protokołu,
który pracuje na opisanej powyżej zasadzie, jest podpis elektroniczny --
\emph{de facto} weryfikuje się tam wyłącznie autentyczność skrótu wiadomości, a
nie samą wiadomość.
\end{itemize}

\subsubsection{Bezpieczne przechowywanie / weryfikacja haseł}
\label{sec:usage_password_check}
Funkcje haszujące przychodzą z pomocą także w weryfikacji haseł. Wyobraźmy
sobie przeciętny mechanizm autentykacji...

\begin{enumerate}
\item Użytkownik Alicja przesyła swoje dane uwierzytelniające do serwera.
\item Serwer odbiera dane.
\item Serwer porównuje dane z wzorcem przechowywanym w bazie danych:
\label{enu:server_pass_check}
    \begin{enumerate}[label*=\arabic*.]
    \item jeżeli dane uwierzytelniające się zgadzają, serwer udziela dostępu
    Alicji,
    \item w przeciwnym wypadku serwer odmawia dostępu Alicji.
    \end{enumerate}
\end{enumerate}

Z takim podejściem wiąże się parę problemów. Po pierwsze, dane, która przesyła
Alicja, mogą zostać przechwycone przez osobę trzecią, zatem wymagają
zaszyfrowania (np. poprzez opakowanie transmisji protokołem \texttt{HTTPS}).
Jednak nie ten problem okazuje się ważny z punktu widzenia funkcji haszujących.
Nas zainteresuje problem wiążący się z punktem \ref{enu:server_pass_check} --
co w wypadku, kiedy do bazy danych serwera, z jakichkolwiek przyczyn, uzyskuje
dostęp ktoś niepożądany? Taka osoba może wówczas podejrzeć dane
uwierzytelniające \emph{wszystkich} użytkowników, także Alicji, a następnie
pomyślnie zalogować przy pomocy tak wykradzionych danych.

Musimy zatem jakoś zabezpieczyć bazę danych. Można próbować ją szyfrować lub
inaczej zabezpieczać dane w niej przechowywane, problem z takim podejściem jest
jednak taki, że na pewnym poziomie tak czy inaczej jakaś osoba (administrator)
zawsze będzie miał dostęp do fizycznych danych. Możemy także zahaszować dane
uwierzytelniające i zmodyfikować nasz protokół w następujący sposób:

\begin{enumerate}
\item Użytkownik Alicja przesyła swoje dane uwierzytelniające do serwera.
\item Serwer odbiera dane.
\item Serwer wylicza na ich podstawie hasz $H$.
\item Serwer porównuje hasz $H$ z wzorcowym haszem $H'$ przechowywanym w bazie
danych:
    \begin{enumerate}[label*=\arabic*.]
    \item jeżeli skróty się zgadzają, serwer udziela dostępu
    Alicji,
    \item w przeciwnym wypadku serwer odmawia dostępu Alicji.
    \end{enumerate}
\end{enumerate}

Dzięki temu, że w bazie przechowywane są jedynie nieodwracalne skróty, nawet w
przypadku kradzieży bazy danych na podstawie wykradzionych skrótów nie powinno
być można odtworzyć oryginalnych danych. Teoretycznie zatem atakującemu taka
baza w zasadzie do niczego się nie przyda.

Należy jednak zwrócić uwagę, że protokół ten nie jest bezpieczny bez pewnych
poprawek. Przyczyny i natura poprawek omówione są w części
\ref{sec:universal_attacks}.

\subsubsection{Jednoznaczna identyfikacja danych}

Innym zastosowaniem funkcji haszujących jest identyfikacja ciągów bajtów, a w
szerszym ujęciu -- plików, struktur/obiektów programistycznych itp. Poniżej
znajdują się przykłady wykorzystania tego pomysłu w różnego rodzaju
rozwiązaniach.
\begin{itemize}
\item Systemy kontroli wersji, w tym Mercurial oraz Git, wykorzystują funkcje
skrótu w celu bezpiecznej identyfikacji konkretnych wersji pliku, numerowania
kolejnych zmian i bezpiecznego przechowywania historycznej struktury
repozytorium.
\item Linki ed2k oraz magnet, używane w sieciach peer-to-peer, wykorzystują
funkcje skrótu w celu lokalizacji źródeł, skąd dany plik może być pobrany, a
także weryfikacji już ściągniętych danych (patrz punkt
\ref{sec:usage_integrity_check}).
\item Struktury danych takie jak tablice mieszające (tzn. tablice, których
kluczami może być dowolny obiekt, w przeciwieństwie do klasycznych tablic o
indeksach liczbowych), wykorzystują funkcje haszujące do serializacji dowolnych
obiektów na taką postać, jaką ich algorytmy indeksowania są w stanie obsłużyć.
Przykładowo, w języku Java każdy zdefiniowany przez użytkownika obiekt powinien
zaimplementować metodę \texttt{hashCode()}, która w zamierzeniu ma pozwolić
łatwo odróżniać (na~tyle, na~ile to możliwe) konkretne instancje obiektu w
stosunku do pozostałych.
\end{itemize}

Biorąc pod uwagę fakt, że kryptograficzne funkcje skrótu są dużo bardziej
kosztowne obliczeniowo niż zwykłe, nieodporne na ataki funkcje haszujące, w
większości tego typu zastosowań korzystanie z kryptograficznych funkcje skrótu
postrzegane jest jako przesada i stosowane są zwyczajne funkcje skrótu. Mimo
to, czasem jednak bezpieczeństwo jest konieczne, szczególnie w sytuacjach
opisanych powyżej, gdzie ryzyko ataku jest wysokie. Przykładowo, atakujący może
stworzyć plik zawierający wirus, którego hasz byłby taki sam jak skrót całkiem
niewinnego pliku, po czym umieścić taki plik w sieci peer-to-peer -- dzięki
zastosowaniu kryptograficznych funkcji skrótu, taki scenariusz jest bez
porównania trudniejszy do skutecznego przeprowadzenia.



\newpage

\subsection{Rys historyczny}

\section{Konstrukcja funkcji haszujących}
\label{sec:hash_construction}

\subsection{Funkcja doskonała}

\subsection{Funkcja jednokierunkowa}

\subsection{Współczesne implementacje}

\subsubsection{Konstrukcja Merkle-Damgarda}

\subsubsection{MD5}

\subsubsection{SHA-1}

\section{Ataki uniwersalne}
\label{sec:universal_attacks}

\subsection{Atak brutalny}

\subsection{Atak słownikowy}

\subsubsection{Odwrócony atak słownikowy}

\subsection{Tęczowe tablice}

\subsection{Ataki typu Denial of Service}

\section{Ataki teoretyczne}

\section{Podsumowanie}

\end{document}
